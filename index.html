<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python配列学習アプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center; /* Center vertically to utilize full height */
            min-height: 100vh; /* Ensure full viewport height */
            padding: 8px; /* Reduced padding for more space */
            box-sizing: border-box;
            overflow: hidden; /* Prevent body scrolling */
        }
        .container {
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1); /* Smaller shadow */
            padding: 16px; /* Reduced padding */
            width: 100%;
            max-width: 600px;
            height: calc(100vh - 16px); /* Adjust height to fit viewport, accounting for body padding */
            display: flex;
            flex-direction: column;
            gap: 8px; /* Reduced gap between sections */
            overflow-y: auto; /* Allow internal scrolling if content overflows */
        }
        .list-display-section {
            background-color: #e2e8f0; /* Lighter gray background */
            border-radius: 8px;
            padding: 8px; /* Reduced padding */
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
            flex-shrink: 0; /* Prevent shrinking */
        }
        .list-display {
            min-height: 40px; /* Further reduced min-height */
            max-height: 80px; /* Max height to prevent excessive vertical growth */
            display: flex;
            flex-wrap: wrap;
            gap: 4px; /* Even smaller gap for items */
            align-items: center;
            justify-content: center; /* Center items for better appearance */
            overflow-x: auto; /* Allow horizontal scroll if many items */
            overflow-y: hidden; /* Hide vertical scrollbar if max-height is hit */
            padding-bottom: 2px; /* Space for scrollbar */
        }
        .list-item {
            background-color: #4a90e2; /* Blue */
            color: white;
            padding: 4px 8px; /* Further reduced padding */
            border-radius: 5px; /* Slightly smaller radius */
            font-weight: 600;
            font-size: 0.8rem; /* Smaller font */
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            flex-shrink: 0; /* Prevent shrinking */
        }

        /* Animation for append/insert: fly-in */
        @keyframes fly-in {
            from {
                opacity: 0;
                transform: scale(0.5) translate(0, 0); /* Start at its initial position, scaled */
            }
            to {
                opacity: 1;
                transform: scale(1) translate(var(--delta-x), var(--delta-y)); /* Move to final position */
            }
        }
        .animated-item {
            position: absolute;
            z-index: 1000; /* Ensure it's on top */
            background-color: #4a90e2; /* Match list item color */
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-weight: 600;
            font-size: 0.8rem;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            /* transition removed as animation will handle movement */
        }

        /* Animation for pop/remove: fly-out */
        @keyframes fly-out {
            from {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            to {
                opacity: 0;
                transform: translate(0, -50px) scale(0.5); /* Move up and fade out */
            }
        }
        .list-item.is-removing {
            position: absolute; /* Take it out of flow */
            animation: fly-out 0.5s ease-in forwards; /* Apply fly-out animation */
            z-index: 999;
        }

        /* Animation for index: pulse highlight */
        @keyframes pulse-highlight {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245, 158, 11, 0); }
        }
        .list-item.highlight {
            background-color: #f59e0b; /* Amber for highlight */
            animation: pulse-highlight 1s ease-out; /* Apply pulse animation */
        }

        /* Temporary highlight for insert target */
        .list-item.insert-target-highlight {
            background-color: #8b5cf6; /* Purple for target highlight */
            box-shadow: 0 0 0 3px #8b5cf6;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* Animation for searching (remove/index) */
        @keyframes searching-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .list-item.searching {
            animation: searching-pulse 0.3s ease-in-out;
        }

        /* Animation for value moving to output field (pop) */
        @keyframes move-to-output {
            from {
                opacity: 1;
                transform: translate(0, 0); /* Start at its initial absolute position */
            }
            to {
                opacity: 1;
                transform: translate(var(--delta-x), var(--delta-y)); /* Move to target */
            }
        }
        .pop-output-item {
            position: absolute;
            z-index: 1000;
            background-color: #4a90e2;
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-weight: 600;
            font-size: 0.8rem;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            /* transition removed */
        }

        /* Animation for value moving to final output (pop) */
        @keyframes move-to-final-output {
            from {
                opacity: 1;
                transform: translate(0, 0); /* Start at its initial absolute position */
            }
            to {
                opacity: 1;
                transform: translate(var(--delta-x), var(--delta-y)); /* Move to target */
            }
        }
        .final-output-item {
            position: absolute;
            z-index: 1000;
            background-color: #60a5fa; /* Lighter blue for final output */
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-weight: 600;
            font-size: 0.8rem;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            /* transition removed */
        }


        .input-group {
            display: flex;
            flex-direction: column;
            gap: 4px; /* Even smaller gap */
            margin-bottom: 6px; /* Even smaller margin */
        }
        .input-group label {
            font-weight: 600;
            color: #475569; /* Slate gray */
            font-size: 0.75rem; /* text-xs */
        }
        .input-group input[type="text"],
        .input-group input[type="number"] {
            padding: 6px 8px; /* Further reduced padding */
            border: 1px solid #cbd5e1;
            border-radius: 6px; /* Slightly smaller radius */
            font-size: 0.8rem; /* Smaller font */
            width: 100%;
            box-sizing: border-box;
        }
        .action-button {
            background-color: #10b981; /* Emerald green */
            color: white;
            padding: 8px 12px; /* Further reduced padding */
            border-radius: 8px; /* Smaller radius */
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Smaller shadow */
            font-size: 0.85rem; /* Smaller font */
        }
        .action-button:hover {
            background-color: #059669; /* Darker emerald */
            transform: translateY(-1px);
        }
        .action-button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        .message-box {
            background-color: #fff;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 8px; /* Reduced padding */
            font-size: 0.75rem; /* Smaller font */
            color: #374151; /* Gray */
            min-height: 30px; /* Further reduced min-height */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            flex-shrink: 0; /* Prevent shrinking */
        }
        .message-box.success {
            background-color: #d1fae5; /* Light green */
            border-color: #34d399; /* Green */
            color: #065f46; /* Dark green */
        }
        .message-box.error {
            background-color: #fee2e2; /* Light red */
            border-color: #ef4444; /* Red */
            color: #991b1b; /* Dark red */
        }
        .section-title {
            font-size: 1rem; /* text-base */
            font-weight: 700; /* font-bold */
            color: #1f2937; /* Gray-900 */
            margin-bottom: 6px; /* Reduced margin */
            text-align: center;
        }

        /* Grid for function panels */
        .function-grid {
            display: grid;
            grid-template-columns: 1fr; /* Default to single column */
            gap: 8px; /* Reduced gap */
            flex-grow: 1; /* Allow grid to take available space */
            overflow-y: auto; /* Allow scrolling within the grid if needed */
            padding-right: 4px; /* Space for scrollbar */
        }
        .function-panel {
            background-color: #fafafa; /* Lighter background for panels */
            padding: 12px; /* Reduced padding */
            border-radius: 12px; /* Slightly smaller radius */
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08); /* Smaller shadow */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Distribute space */
        }
        .function-panel p {
            margin-bottom: 8px; /* Reduced margin */
        }
        .pop-output-field {
            background-color: #e0f2f7; /* Light blue */
            border: 1px solid #a7d9ee;
            border-radius: 6px;
            padding: 6px 8px;
            margin-top: 8px;
            font-size: 0.8rem;
            color: #0056b3;
            text-align: center;
            min-height: 28px; /* Ensure it has some height */
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* For animation target */
        }
        .final-pop-output-field {
            background-color: #d1fae5; /* Light green */
            border: 1px solid #34d399;
            border-radius: 6px;
            padding: 6px 8px;
            margin-top: 4px; /* Closer to pop output */
            font-size: 0.8rem;
            color: #065f46;
            text-align: center;
            min-height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }


        /* Responsive adjustments */
        @media (min-width: 480px) { /* Small phones landscape, or larger phones portrait */
            .function-grid {
                grid-template-columns: repeat(2, 1fr); /* 2 columns for wider screens */
            }
            .function-panel.full-width {
                grid-column: span 2; /* Index function takes full width */
            }
        }

        @media (min-width: 640px) { /* sm breakpoint */
            .input-group.horizontal {
                flex-direction: row;
                align-items: center;
            }
            .input-group.horizontal label {
                flex-shrink: 0;
                width: 60px; /* Fixed width for labels in horizontal groups */
            }
            .input-group.horizontal input {
                flex-grow: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-xl font-extrabold text-center text-gray-900 mb-2">Python配列学習アプリ</h1>

        <div class="list-display-section">
            <h2 class="section-title">現在のリスト:</h2>
            <div id="listDisplay" class="list-display">
                </div>
        </div>

        <div id="messageBox" class="message-box">
            ここに操作結果が表示されます。
        </div>

        <div class="function-grid">
            <div class="function-panel">
                <h2 class="section-title">a.append(x)</h2>
                <p class="text-gray-600 mb-2 text-xs">リストの末尾に要素を追加します。</p>
                <div class="input-group">
                    <label for="appendValue">値:</label>
                    <input type="text" id="appendValue" placeholder="例: apple">
                </div>
                <button class="action-button" onclick="appendItem()">追加 (append)</button>
            </div>

            <div class="function-panel">
                <h2 class="section-title">a.insert(i, x)</h2>
                <p class="text-gray-600 mb-2 text-xs">指定したインデックスに要素を挿入します。</p>
                <div class="input-group horizontal">
                    <label for="insertIndex">インデックス:</label>
                    <input type="number" id="insertIndex" placeholder="例: 0">
                </div>
                <div class="input-group horizontal">
                    <label for="insertValue">値:</label>
                    <input type="text" id="insertValue" placeholder="例: banana">
                </div>
                <button class="action-button" onclick="insertItem()">挿入 (insert)</button>
            </div>

            <div class="function-panel">
                <h2 class="section-title">a.pop() / a.pop(i)</h2>
                <p class="text-gray-600 mb-2 text-xs">末尾または指定インデックスの要素を削除し、その値を返します。</p>
                <div class="input-group">
                    <label for="popIndex">インデックス (オプション):</label>
                    <input type="number" id="popIndex" placeholder="空欄で末尾を削除">
                </div>
                <button class="action-button" onclick="popItem()">削除 (pop)</button>
                <div id="popOutput" class="pop-output-field mt-2">
                    print(a.pop(i))
                </div>
                <div id="finalPopOutput" class="final-pop-output-field">
                    出力:
                </div>
            </div>

            <div class="function-panel">
                <h2 class="section-title">a.remove(x)</h2>
                <p class="text-gray-600 mb-2 text-xs">最初に見つかった指定の値を削除します。</p>
                <div class="input-group">
                    <label for="removeValue">削除する値:</label>
                    <input type="text" id="removeValue" placeholder="例: apple">
                </div>
                <button class="action-button" onclick="removeItem()">削除 (remove)</button>
            </div>

            <div class="function-panel full-width">
                <h2 class="section-title">a.index(x)</h2>
                <p class="text-gray-600 mb-2 text-xs">最初に見つかった指定の要素のインデックスを返します。</p>
                <div class="input-group">
                    <label for="indexValue">検索する値:</label>
                    <input type="text" id="indexValue" placeholder="例: banana">
                </div>
                <button class="action-button" onclick="findItemIndex()">インデックス検索 (index)</button>
            </div>
        </div>

        <button class="action-button bg-purple-600 hover:bg-purple-700 mt-2 flex-shrink-0" onclick="resetList()">
            リストをリセット
        </button>
    </div>

    <script>
        let myList = []; // PythonのリストをシミュレートするJavaScript配列
        const ANIMATION_DURATION = 500; // アニメーションの持続時間 (ミリ秒)
        const SEARCH_STEP_DURATION = 300; // 探索アニメーションの各ステップの持続時間

        // DOM要素の取得
        const listDisplay = document.getElementById('listDisplay');
        const messageBox = document.getElementById('messageBox');
        const popOutput = document.getElementById('popOutput');
        const finalPopOutput = document.getElementById('finalPopOutput');

        /**
         * 指定されたミリ秒だけ待機するヘルパー関数
         * @param {number} ms - 待機するミリ秒
         * @returns {Promise<void>}
         */
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * リストの表示を更新する関数
         * @param {number|null} highlightIndex - ハイライトする要素のインデックス (オプション)
         * @param {number|null} insertTargetIndex - 挿入ターゲットをハイライトするインデックス (オプション)
         */
        function updateListDisplay(highlightIndex = null, insertTargetIndex = null) {
            listDisplay.innerHTML = ''; // 現在の表示をクリア
            if (myList.length === 0) {
                listDisplay.innerHTML = '<p class="text-gray-500 text-sm">リストは空です。</p>';
                // If inserting into an empty list, show a target highlight at the beginning
                if (insertTargetIndex === 0) {
                    const targetDiv = document.createElement('div');
                    targetDiv.classList.add('list-item', 'insert-target-highlight');
                    targetDiv.textContent = 'ここに挿入';
                    listDisplay.appendChild(targetDiv);
                }
                return;
            }

            myList.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('list-item');
                itemDiv.textContent = item;

                // Insert target highlight before the actual item at the index
                if (insertTargetIndex !== null && index === insertTargetIndex) {
                    const targetDiv = document.createElement('div');
                    targetDiv.classList.add('list-item', 'insert-target-highlight');
                    targetDiv.textContent = 'ここに挿入'; // Placeholder for visual target
                    listDisplay.appendChild(targetDiv);
                }

                listDisplay.appendChild(itemDiv);
            });

            // Handle insert target highlight for appending to the end
            if (insertTargetIndex !== null && insertTargetIndex === myList.length) {
                const targetDiv = document.createElement('div');
                targetDiv.classList.add('list-item', 'insert-target-highlight');
                targetDiv.textContent = 'ここに挿入';
                listDisplay.appendChild(targetDiv);
            }

            // Apply highlight animation after the DOM is updated
            if (highlightIndex !== null && listDisplay.children[highlightIndex]) {
                const highlightedElement = listDisplay.children[highlightIndex];
                highlightedElement.classList.add('highlight');
                // Remove highlight after animation duration
                setTimeout(() => {
                    highlightedElement.classList.remove('highlight');
                }, ANIMATION_DURATION * 2); // Longer duration for pulse
            }
        }

        /**
         * メッセージボックスにメッセージを表示する関数
         * @param {string} message - 表示するメッセージ
         * @param {string} type - 'success', 'error', または 'info'
         */
        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.className = 'message-box'; // Reset classes
            if (type === 'success') {
                messageBox.classList.add('success');
            } else if (type === 'error') {
                messageBox.classList.add('error');
            }
        }

        // 初期表示
        updateListDisplay();
        showMessage('操作を選択してPythonのリスト関数を試してみましょう！');
        popOutput.textContent = 'print(a.pop(i))'; // Initial text for pop output
        finalPopOutput.textContent = '出力:'; // Initial text for final pop output

        /**
         * append(x) 関数をシミュレート
         */
        async function appendItem() {
            const value = document.getElementById('appendValue').value.trim();
            if (value === '') {
                showMessage('追加する値を入力してください。', 'error');
                return;
            }

            const appendInput = document.getElementById('appendValue');
            const startRect = appendInput.getBoundingClientRect();

            // アニメーション用の要素を作成
            const animatedItem = document.createElement('div');
            animatedItem.classList.add('animated-item');
            animatedItem.textContent = value;
            document.body.appendChild(animatedItem);

            // 開始位置を設定 (入力フィールドの場所)
            animatedItem.style.left = startRect.left + 'px';
            animatedItem.style.top = startRect.top + 'px';

            // アニメーションの目標位置を計算 (リストの末尾)
            let targetX, targetY;
            const listDisplayRect = listDisplay.getBoundingClientRect();

            if (myList.length === 0) {
                // If list is empty, target the center of the list display
                targetX = listDisplayRect.left + (listDisplayRect.width / 2) - (animatedItem.offsetWidth / 2);
                targetY = listDisplayRect.top + (listDisplayRect.height / 2) - (animatedItem.offsetHeight / 2);
            } else {
                // Target position is after the last item in the list
                // Need to get the actual position where the new item will settle
                // This requires a temporary item or a more complex calculation based on current items' positions
                const lastItem = listDisplay.lastElementChild;
                const lastItemRect = lastItem.getBoundingClientRect();
                targetX = lastItemRect.right + 4; // 4px gap
                targetY = lastItemRect.top;
            }

            // Calculate delta for transform
            const deltaX = targetX - startRect.left;
            const deltaY = targetY - startRect.top;

            // Set CSS variables for animation
            animatedItem.style.setProperty('--delta-x', `${deltaX}px`);
            animatedItem.style.setProperty('--delta-y', `${deltaY}px`);

            // Start animation
            animatedItem.style.animation = `fly-in ${ANIMATION_DURATION / 1000}s ease-out forwards`;

            await sleep(ANIMATION_DURATION);

            animatedItem.remove(); // Remove animated item
            myList.push(value);
            updateListDisplay(myList.length - 1); // Highlight newly added item
            showMessage(`'${value}' をリストの末尾に追加しました。`, 'success');
            document.getElementById('appendValue').value = ''; // Clear input
        }

        /**
         * insert(i, x) 関数をシミュレート
         */
        async function insertItem() {
            const index = parseInt(document.getElementById('insertIndex').value);
            const value = document.getElementById('insertValue').value.trim();

            if (isNaN(index)) {
                showMessage('挿入するインデックスを数値で入力してください。', 'error');
                return;
            }
            if (value === '') {
                showMessage('挿入する値を入力してください。', 'error');
                return;
            }
            if (index < 0 || index > myList.length) {
                showMessage(`インデックス ${index} は無効です。0から${myList.length}の間で指定してください。`, 'error');
                return;
            }

            // First, highlight the insert target
            updateListDisplay(null, index);
            await sleep(ANIMATION_DURATION / 2); // Wait to show highlight

            const insertInput = document.getElementById('insertValue');
            const startRect = insertInput.getBoundingClientRect();

            // Create animated item
            const animatedItem = document.createElement('div');
            animatedItem.classList.add('animated-item');
            animatedItem.textContent = value;
            document.body.appendChild(animatedItem);

            // Set initial position
            animatedItem.style.left = startRect.left + 'px';
            animatedItem.style.top = startRect.top + 'px';

            // Calculate target position in the list
            let targetX, targetY;
            const listDisplayRect = listDisplay.getBoundingClientRect();

            if (myList.length === 0) {
                // If list is empty, target the center of list display
                targetX = listDisplayRect.left + (listDisplayRect.width / 2) - (animatedItem.offsetWidth / 2);
                targetY = listDisplayRect.top + (listDisplayRect.height / 2) - (animatedItem.offsetHeight / 2);
            } else if (index === myList.length) {
                // If inserting at the end, target after the last item
                const lastItem = listDisplay.lastElementChild;
                const lastItemRect = lastItem.getBoundingClientRect();
                targetX = lastItemRect.right + 4; // 4px gap
                targetY = lastItemRect.top;
            } else {
                // Target position is the specified index item's position
                const targetElement = listDisplay.children[index];
                const targetRect = targetElement.getBoundingClientRect();
                targetX = targetRect.left;
                targetY = targetRect.top;
            }

            // Calculate delta for transform
            const deltaX = targetX - startRect.left;
            const deltaY = targetY - startRect.top;

            // Set CSS variables for animation
            animatedItem.style.setProperty('--delta-x', `${deltaX}px`);
            animatedItem.style.setProperty('--delta-y', `${deltaY}px`);

            // Start animation
            animatedItem.style.animation = `fly-in ${ANIMATION_DURATION / 1000}s ease-out forwards`;

            await sleep(ANIMATION_DURATION);

            animatedItem.remove(); // Remove animated item
            myList.splice(index, 0, value);
            updateListDisplay(index); // Highlight newly inserted item
            showMessage(`インデックス ${index} に '${value}' を挿入しました。`, 'success');
            document.getElementById('insertIndex').value = '';
            document.getElementById('insertValue').value = '';
        }

        /**
         * pop() / pop(i) 関数をシミュレート
         */
        async function popItem() {
            const indexInput = document.getElementById('popIndex').value;
            let removedValue;
            let removedIdx;

            // Clear previous output
            popOutput.textContent = 'print(a.pop(i))';
            finalPopOutput.textContent = '出力:';

            if (myList.length === 0) {
                showMessage('リストが空なので、popできません。', 'error');
                return;
            }

            if (indexInput === '') { // pop() (末尾を削除)
                removedIdx = myList.length - 1; // Index of item to be removed
                removedValue = myList[removedIdx];
            } else { // pop(i) (delete at specified index)
                const index = parseInt(indexInput);
                if (isNaN(index) || index < 0 || index >= myList.length) {
                    showMessage(`インデックス ${index} は無効です。0から${myList.length - 1}の間で指定してください。`, 'error');
                    return;
                }
                removedIdx = index;
                removedValue = myList[removedIdx];
            }

            const itemToAnimate = listDisplay.children[removedIdx];
            if (itemToAnimate) {
                // Get current position and size of the element, then make it absolute
                const rect = itemToAnimate.getBoundingClientRect();
                itemToAnimate.style.position = 'absolute';
                itemToAnimate.style.left = rect.left + 'px';
                itemToAnimate.style.top = rect.top + 'px';
                itemToAnimate.style.width = rect.width + 'px';
                itemToAnimate.style.height = rect.height + 'px';

                itemToAnimate.classList.add('is-removing'); // Start fly-out animation

                // Animate removed value moving to popOutput field
                const popOutputRect = popOutput.getBoundingClientRect();

                const animatedOutputItem = document.createElement('div');
                animatedOutputItem.classList.add('pop-output-item');
                animatedOutputItem.textContent = removedValue;
                document.body.appendChild(animatedOutputItem);

                // Set initial position of animated output item (from where the removed item was)
                animatedOutputItem.style.left = rect.left + 'px';
                animatedOutputItem.style.top = rect.top + 'px';

                // Calculate target position for popOutput field (center of it)
                const targetX_popOutput = popOutputRect.left + (popOutputRect.width / 2) - (animatedOutputItem.offsetWidth / 2);
                const targetY_popOutput = popOutputRect.top + (popOutputRect.height / 2) - (animatedOutputItem.offsetHeight / 2);

                // Calculate delta for transform
                const deltaX_popOutput = targetX_popOutput - rect.left;
                const deltaY_popOutput = targetY_popOutput - rect.top;

                animatedOutputItem.style.setProperty('--delta-x', `${deltaX_popOutput}px`);
                animatedOutputItem.style.setProperty('--delta-y', `${deltaY_popOutput}px`);

                animatedOutputItem.style.animation = `move-to-output ${ANIMATION_DURATION / 1000}s ease-out forwards`;

                await sleep(ANIMATION_DURATION); // Wait for item to move to popOutput

                animatedOutputItem.remove(); // Remove the item that moved to popOutput
            }

            myList.splice(removedIdx, 1); // Remove item from list
            updateListDisplay(); // Update display
            showMessage(`'${removedValue}' を削除しました。`, 'success');
            popOutput.textContent = `print(${removedValue})`; // Update pop output field

            // Now, animate the value from popOutput to finalPopOutput
            const finalPopOutputRect = finalPopOutput.getBoundingClientRect();
            const popOutputRect = popOutput.getBoundingClientRect();

            const finalAnimatedItem = document.createElement('div');
            finalAnimatedItem.classList.add('final-output-item');
            finalAnimatedItem.textContent = removedValue;
            document.body.appendChild(finalAnimatedItem);

            // Start position is from the center of popOutput field
            const startX_final = popOutputRect.left + (popOutputRect.width / 2) - (finalAnimatedItem.offsetWidth / 2);
            const startY_final = popOutputRect.top + (popOutputRect.height / 2) - (finalAnimatedItem.offsetHeight / 2);

            finalAnimatedItem.style.left = startX_final + 'px';
            finalAnimatedItem.style.top = startY_final + 'px';

            // End position is the center of finalPopOutput field
            const endX_final = finalPopOutputRect.left + (finalPopOutputRect.width / 2) - (finalAnimatedItem.offsetWidth / 2);
            const endY_final = finalPopOutputRect.top + (finalPopOutputRect.height / 2) - (finalAnimatedItem.offsetHeight / 2);

            // Calculate delta for transform
            const deltaX_final = endX_final - startX_final;
            const deltaY_final = endY_final - startY_final;

            finalAnimatedItem.style.setProperty('--delta-x', `${deltaX_final}px`);
            finalAnimatedItem.style.setProperty('--delta-y', `${deltaY_final}px`);

            finalAnimatedItem.style.animation = `move-to-final-output ${ANIMATION_DURATION / 1000}s ease-out forwards`;

            await sleep(ANIMATION_DURATION); // Wait for item to move to finalPopOutput

            finalAnimatedItem.remove(); // Remove the animated item
            finalPopOutput.textContent = `出力: ${removedValue}`; // Set final output text
            document.getElementById('popIndex').value = '';
        }

        /**
         * remove(x) 関数をシミュレート
         */
        async function removeItem() {
            const value = document.getElementById('removeValue').value.trim();
            if (value === '') {
                showMessage('削除する値を入力してください。', 'error');
                return;
            }

            let foundIndex = -1;
            for (let i = 0; i < myList.length; i++) {
                const itemDiv = listDisplay.children[i];
                if (!itemDiv) continue; // Safety check

                itemDiv.classList.add('searching'); // 探索アニメーション開始
                await sleep(SEARCH_STEP_DURATION);

                if (myList[i] === value) {
                    foundIndex = i;
                    itemDiv.classList.remove('searching'); // 探索アニメーション終了
                    break; // 見つかったらループを抜ける
                } else {
                    itemDiv.classList.remove('searching'); // 目的の値でなければ元に戻す
                }
            }

            if (foundIndex === -1) {
                showMessage(`'${value}' はリストに見つかりませんでした。`, 'error');
                return;
            }

            const itemToAnimate = listDisplay.children[foundIndex];
            if (itemToAnimate) {
                const rect = itemToAnimate.getBoundingClientRect();
                itemToAnimate.style.position = 'absolute';
                itemToAnimate.style.left = rect.left + 'px';
                itemToAnimate.style.top = rect.top + 'px';
                itemToAnimate.style.width = rect.width + 'px';
                itemToAnimate.style.height = rect.height + 'px';
                itemToAnimate.classList.add('is-removing'); // 削除アニメーション開始
            }

            await sleep(ANIMATION_DURATION);

            myList.splice(foundIndex, 1); // リストから要素を削除
            updateListDisplay(); // 表示を更新
            showMessage(`最初に見つかった '${value}' を削除しました。`, 'success');
            document.getElementById('removeValue').value = '';
        }

        /**
         * index(x) 関数をシミュレート
         */
        async function findItemIndex() {
            const value = document.getElementById('indexValue').value.trim();
            if (value === '') {
                showMessage('検索する値を入力してください。', 'error');
                return;
            }

            let foundIndex = -1;
            for (let i = 0; i < myList.length; i++) {
                const itemDiv = listDisplay.children[i];
                if (!itemDiv) continue; // Safety check

                itemDiv.classList.add('searching'); // 探索アニメーション開始
                await sleep(SEARCH_STEP_DURATION);

                if (myList[i] === value) {
                    foundIndex = i;
                    itemDiv.classList.remove('searching'); // 探索アニメーション終了
                    break; // 見つかったらループを抜ける
                } else {
                    itemDiv.classList.remove('searching'); // 目的の値でなければ元に戻す
                }
            }

            if (foundIndex === -1) {
                showMessage(`'${value}' はリストに見つかりませんでした。`, 'error');
                updateListDisplay(); // ハイライトを解除
            } else {
                updateListDisplay(foundIndex); // 見つかった要素をハイライト (pulse-highlightアニメーションが適用される)
                showMessage(`'${value}' のインデックスは ${foundIndex} です。`, 'success');
            }
            document.getElementById('indexValue').value = '';
        }

        /**
         * リストをリセットする関数
         */
        function resetList() {
            myList = [];
            updateListDisplay();
            showMessage('リストがリセットされました。', 'info');
            popOutput.textContent = 'print(a.pop(i))'; // Reset pop output text
            finalPopOutput.textContent = '出力:'; // Reset final pop output text
        }
    </script>
</body>
</html>
